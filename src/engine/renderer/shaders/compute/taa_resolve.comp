#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

// TAA Resolve Compute Shader
// Performs temporal anti-aliasing by blending current frame with history

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Input textures
layout(set = 0, binding = 0) uniform sampler2D currentFrame;
layout(set = 0, binding = 1) uniform sampler2D historyFrame;
layout(set = 0, binding = 2) uniform sampler2D velocityBuffer;
layout(set = 0, binding = 3) uniform sampler2D depthBuffer;

// Output image
layout(set = 0, binding = 4, rgba8) uniform image2D outputImage;

// Uniform buffer
layout(set = 0, binding = 5) uniform TAAParams {
    mat4 reprojectionMatrix;
    vec4 jitterOffset;
    vec4 params; // x: blend factor, y: motion blur scale, z: sharpness, w: time
    vec2 resolution;
    vec2 invResolution;
} taa;

// Helper functions
vec3 RGB2YCoCg(vec3 rgb) {
    float y = dot(rgb, vec3(0.25, 0.5, 0.25));
    float co = dot(rgb, vec3(0.5, 0.0, -0.5));
    float cg = dot(rgb, vec3(-0.25, 0.5, -0.25));
    return vec3(y, co, cg);
}

vec3 YCoCg2RGB(vec3 ycocg) {
    float y = ycocg.x;
    float co = ycocg.y;
    float cg = ycocg.z;
    return vec3(
        y + co - cg,
        y + cg,
        y - co - cg
    );
}

vec3 clipAABB(vec3 aabbMin, vec3 aabbMax, vec3 history) {
    vec3 center = 0.5 * (aabbMax + aabbMin);
    vec3 halfSize = 0.5 * (aabbMax - aabbMin);
    vec3 displacement = history - center;
    vec3 direction = displacement / max(halfSize, vec3(0.0001));
    float scale = min(1.0, min(min(
        abs(direction.x) > 0.0 ? 1.0 / abs(direction.x) : 1e10,
        abs(direction.y) > 0.0 ? 1.0 / abs(direction.y) : 1e10),
        abs(direction.z) > 0.0 ? 1.0 / abs(direction.z) : 1e10));
    return center + displacement * scale;
}

void main() {
    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    
    // Check bounds
    if (coords.x >= taa.resolution.x || coords.y >= taa.resolution.y) {
        return;
    }
    
    vec2 uv = (vec2(coords) + 0.5) * taa.invResolution;
    
    // Sample current frame
    vec3 current = texture(currentFrame, uv).rgb;
    
    // Get motion vector
    vec2 velocity = texture(velocityBuffer, uv).rg;
    
    // Calculate reprojected UV
    vec2 historyUV = uv - velocity;
    
    // Check if history UV is valid
    if (historyUV.x < 0.0 || historyUV.x > 1.0 || 
        historyUV.y < 0.0 || historyUV.y > 1.0) {
        // No valid history, use current frame
        imageStore(outputImage, coords, vec4(current, 1.0));
        return;
    }
    
    // Sample history
    vec3 history = texture(historyFrame, historyUV).rgb;
    
    // Neighborhood clamping to reduce ghosting
    vec3 nearMin = current;
    vec3 nearMax = current;
    
    // Sample 3x3 neighborhood
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            if (x == 0 && y == 0) continue;
            
            vec2 sampleUV = uv + vec2(x, y) * taa.invResolution;
            vec3 neighbor = texture(currentFrame, sampleUV).rgb;
            nearMin = min(nearMin, neighbor);
            nearMax = max(nearMax, neighbor);
        }
    }
    
    // Convert to YCoCg space for better clamping
    vec3 currentYCoCg = RGB2YCoCg(current);
    vec3 historyYCoCg = RGB2YCoCg(history);
    vec3 nearMinYCoCg = RGB2YCoCg(nearMin);
    vec3 nearMaxYCoCg = RGB2YCoCg(nearMax);
    
    // Clamp history to neighborhood
    historyYCoCg = clipAABB(nearMinYCoCg, nearMaxYCoCg, historyYCoCg);
    history = YCoCg2RGB(historyYCoCg);
    
    // Calculate blend factor based on motion
    float velocityMagnitude = length(velocity);
    float blendFactor = mix(taa.params.x, 0.95, min(velocityMagnitude * 10.0, 1.0));
    
    // Blend current and history
    vec3 result = mix(history, current, blendFactor);
    
    // Store result
    imageStore(outputImage, coords, vec4(result, 1.0));
}